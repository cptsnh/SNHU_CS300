# SNHU_CS300 Journal

## Project description
The purpose of this project is to provide pseudocode, algorithm analysis, and completed code for a course planner that we are going to design for ABC University (ABCU). The pseudocode will consist of functions that pertain to file parsing, creating objects and storing them in a data structure, searching the data structure, and printing the data. I also provide pseudocode for the main menu of the application. The main menu will include options for loading data in the data structure, printing the entire course list, printing information on individual courses, and exiting the application. The course planner is completed using C++, uses the binary search tree to perform the operations listed in the menu.

The main object used in the assignment is a Course class. Each course will contain a string value for its id, a string value for its title, and a vector to store prerequisite courses for the given Course object. In this scenario, the CourseId will be used as the key for the object. I use a vector to store prerequisites because a course can have more than one prerequisite and a vector is suitable for dynamic insertion. The tree data structure is built using objects called Nodes, which store the course object and pointers to children nodes.

## Data Structures discussion
Data structures are important to understand because they are how we can store, retrieve, and act upon data when a programming is running. We need to be able to perform operations as efficiently as possible. As an analogy, I consider data structures to be like a Swiss army knife – we use a specific data structure for a given purpose. As we have learned in this course, a hash table has fantastic insertion, search, and deletion speed, but it may not be a good choice if we need to store sorted data. A binary search tree performs very fast for most operations on the average case, but they can be complex, and we must be careful if using recursion. My approach to the project was to think about it in terms of a much larger system – something a university would implement. So, even though the project was a small set of data, I thought of the data structure being comprised of many courses. I also felt that searching would probably be the most likely operation performed, so that is why I chose the BST for the project.

## Roadblocks and Activities of the project
Overall, I think I completed each assignment and the project very well. I didn’t encounter any roadblocks. The most difficult operation to implement for each data structure was deletion. Deletion required much more thought and situational analysis. Removal from the hash table was by far the most difficult for me.  I overcame this with a lot of testing, research, and trial-and-error. When removing from a specific bucket for example, we must make sure if the sub list only contains one node (in which case, the bucket becomes “empty”), or if it is the tail node, or a node in the middle, or if it is the head, then we must make sure the next node in the list becomes the head and still maintain the bucket. I implemented it successfully; it just took a lot more time and care compared to the other data structures.

## Approach to designing software and developing programs
This project expanded my approach to designing software and developing programs in several ways. First, it helped train my mindset to the perspective of storing information, and how operations on data can be performed in efficient ways. While a nested for loop is easy to write and can solve many problems, it is one of the least efficient ways to perform operations on data. Learning about data structures makes me think about the bigger picture of designing software – it is not just about getting the application to work, but it is equally important to get it working efficiently.

## Skill evolution as a result of this course and project
My work on this project has evolved in several ways. First, by using data structures we are also kind of writing code that is more maintainable, readable, and adaptable. In other words, data structures help to organize our code as much as it helps to organize data to perform operations. Consider that a binary search tree is well understood by most developers. We can discuss a problem more abstractly with that understanding already assumed, and we know how and where the code will be written. If there is a problem with searching for example, it would be logical to check out the BST implementation and how the data is being handled by the BST. Secondly, our code is more adaptable when using data structures. This is especially true when using templates (or generics in Java), as the same data structure can be used for multiple data types. This again promotes maintainable and readable code.


